<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typeahead Search - System Architecture</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #9b59b6;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
        }
        .architecture-diagram {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        .component {
            background: #ecf0f1;
            border: 2px solid #9b59b6;
            border-radius: 8px;
            padding: 15px;
            margin: 10px;
            display: inline-block;
            min-width: 150px;
            text-align: center;
        }
        .component.client { background: #e8f8f5; border-color: #1abc9c; }
        .component.gateway { background: #fef5e7; border-color: #f39c12; }
        .component.search { background: #ebf5fb; border-color: #3498db; }
        .component.trie { background: #fdecea; border-color: #e74c3c; }
        .component.db { background: #f4ecf7; border-color: #9b59b6; }
        .component.cache { background: #ffeaa7; border-color: #fdcb6e; }

        .layer {
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.05);
        }
        .tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
        .tech-badge {
            background: #9b59b6;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }
        .note {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', monospace;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background: #9b59b6;
            color: white;
        }
        tr:nth-child(even) {
            background: #f2f2f2;
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .comparison-box {
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #9b59b6;
        }
        .comparison-box.selected {
            background: #f4ecf7;
        }
    </style>
</head>
<body>
    <h1>üîç Typeahead Search - System Architecture</h1>

    <div class="note">
        <strong>System Goal:</strong> Design a real-time search suggestion system (like Google Search, Amazon Product Search) that provides instant autocomplete suggestions as users type.
    </div>

    <h2>üìä High-Level Architecture</h2>
    <div class="architecture-diagram">
        <div class="layer">
            <h3>Client Layer</h3>
            <div class="component client">Web Browser</div>
            <div class="component client">Mobile App</div>
            <div class="component client">Desktop App</div>
        </div>

        <div style="text-align: center; font-size: 30px; color: #95a5a6;">‚¨á</div>

        <div class="layer">
            <h3>Edge Layer</h3>
            <div class="component gateway">CDN (CloudFront)</div>
            <div class="component gateway">API Gateway</div>
            <div class="component gateway">Load Balancer</div>
        </div>

        <div style="text-align: center; font-size: 30px; color: #95a5a6;">‚¨á</div>

        <div class="layer">
            <h3>Service Layer</h3>
            <div class="component search">Typeahead Service</div>
            <div class="component search">Query Aggregator</div>
            <div class="component search">Analytics Service</div>
        </div>

        <div style="text-align: center; font-size: 30px; color: #95a5a6;">‚¨á</div>

        <div class="layer">
            <h3>Data Structures Layer</h3>
            <div class="component trie">Trie / Prefix Tree</div>
            <div class="component cache">Redis Cache</div>
        </div>

        <div style="text-align: center; font-size: 30px; color: #95a5a6;">‚¨á</div>

        <div class="layer">
            <h3>Storage Layer</h3>
            <div class="component db">Suggestions Database</div>
            <div class="component db">Search Logs (Kafka)</div>
            <div class="component db">Analytics DB (ClickHouse)</div>
        </div>
    </div>

    <h2>üèóÔ∏è Component Details</h2>

    <h3>1. Client-Side (Browser/App)</h3>
    <div class="tech-stack">
        <span class="tech-badge">React/Vue.js</span>
        <span class="tech-badge">TypeScript</span>
        <span class="tech-badge">Debouncing</span>
    </div>
    <ul>
        <li><strong>Input Debouncing:</strong> Wait 200-300ms after user stops typing before sending request</li>
        <li><strong>Request Cancellation:</strong> Cancel previous requests when new character typed</li>
        <li><strong>Local Caching:</strong> Browser localStorage for recent searches</li>
        <li><strong>Keyboard Navigation:</strong> Arrow keys, Enter, Escape handling</li>
    </ul>

    <pre><code>// Client-side debouncing example
let debounceTimer;
function onSearchInput(query) {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
        fetchSuggestions(query);
    }, 300); // 300ms delay
}

// Request cancellation
let controller = new AbortController();
function fetchSuggestions(query) {
    controller.abort(); // Cancel previous request
    controller = new AbortController();

    fetch(`/api/suggestions?q=${query}`, {
        signal: controller.signal
    })
    .then(response => response.json())
    .then(suggestions => displaySuggestions(suggestions));
}
</code></pre>

    <h3>2. API Gateway / Load Balancer</h3>
    <div class="tech-stack">
        <span class="tech-badge">AWS API Gateway</span>
        <span class="tech-badge">Kong</span>
        <span class="tech-badge">NGINX</span>
    </div>
    <ul>
        <li><strong>Rate Limiting:</strong> 100 requests/second per IP (prevent spam)</li>
        <li><strong>SSL Termination:</strong> HTTPS handling</li>
        <li><strong>Request Routing:</strong> Route to appropriate service</li>
        <li><strong>Caching Headers:</strong> Set cache-control headers</li>
    </ul>

    <h3>3. Typeahead Service</h3>
    <div class="tech-stack">
        <span class="tech-badge">Go</span>
        <span class="tech-badge">Node.js</span>
        <span class="tech-badge">Java</span>
    </div>
    <ul>
        <li><strong>Query Processing:</strong> Normalize, lowercase, trim input</li>
        <li><strong>Trie Lookup:</strong> Fast prefix matching in memory</li>
        <li><strong>Ranking:</strong> Sort by popularity, relevance, recency</li>
        <li><strong>Personalization:</strong> User history, location-based results</li>
    </ul>

    <pre><code>// Typeahead service pseudocode
async function getSuggestions(query, limit = 10) {
    // 1. Normalize query
    query = query.toLowerCase().trim();

    if (query.length < 2) {
        return []; // Minimum 2 characters
    }

    // 2. Check Redis cache first
    cacheKey = `suggestions:${query}`;
    cached = await redis.get(cacheKey);
    if (cached) {
        return JSON.parse(cached);
    }

    // 3. Query Trie for prefix matches
    matches = trie.findByPrefix(query);

    // 4. Rank by score (popularity, recency, relevance)
    ranked = rankSuggestions(matches, query);

    // 5. Take top N
    suggestions = ranked.slice(0, limit);

    // 6. Cache result
    await redis.set(cacheKey, JSON.stringify(suggestions), 'EX', 3600);

    return suggestions;
}
</code></pre>

    <h3>4. Trie (Prefix Tree) - Core Data Structure</h3>
    <div class="tech-stack">
        <span class="tech-badge">In-Memory</span>
        <span class="tech-badge">C++/Go</span>
        <span class="tech-badge">Redis Sorted Sets</span>
    </div>

    <h4>What is a Trie?</h4>
    <pre><code>Example Trie for words: "cat", "cap", "car", "dog", "door"

                    root
                   /    \
                  c      d
                  |      |
                  a      o
                /|\      |\
               t p r     g r
             (cat)(cap)(car)(dog)(door)

Lookup "ca" ‚Üí Returns: ["cat", "cap", "car"]
Lookup "do" ‚Üí Returns: ["dog", "door"]
</code></pre>

    <h4>Trie Implementation</h4>
    <pre><code>class TrieNode {
    children: Map<char, TrieNode>
    isEndOfWord: boolean
    frequency: int       // How many times searched
    suggestions: []string // Top 10 suggestions for this prefix
}

class Trie {
    root: TrieNode

    insert(word, frequency):
        node = root
        for char in word:
            if char not in node.children:
                node.children[char] = new TrieNode()
            node = node.children[char]
        node.isEndOfWord = true
        node.frequency = frequency

    findByPrefix(prefix):
        node = root
        for char in prefix:
            if char not in node.children:
                return []
            node = node.children[char]

        // Return pre-computed top suggestions
        return node.suggestions

    // Pre-compute top suggestions at each node
    precomputeSuggestions(node, maxSuggestions = 10):
        suggestions = []
        collectSuggestions(node, "", suggestions)
        node.suggestions = sortByFrequency(suggestions).top(maxSuggestions)
}
</code></pre>

    <div class="note">
        <strong>Trie Advantages:</strong><br>
        ‚Ä¢ O(k) lookup time where k = query length (very fast!)<br>
        ‚Ä¢ Efficient for prefix matching<br>
        ‚Ä¢ Compact storage (shared prefixes)<br>
        ‚Ä¢ Easy to update incrementally
    </div>

    <h3>5. Redis Cache Layer</h3>
    <div class="tech-stack">
        <span class="tech-badge">Redis Cluster</span>
        <span class="tech-badge">ElastiCache</span>
    </div>

    <h4>Cache Strategy</h4>
    <ul>
        <li><strong>Cache Key:</strong> <code>suggestions:{query}</code></li>
        <li><strong>Value:</strong> JSON array of suggestions</li>
        <li><strong>TTL:</strong> 1 hour (suggestions don't change rapidly)</li>
        <li><strong>Eviction:</strong> LRU (Least Recently Used)</li>
    </ul>

    <pre><code>// Redis structure
Key:   suggestions:iphone
Value: ["iphone 15", "iphone 15 pro", "iphone 14", "iphone case", ...]
TTL:   3600 seconds (1 hour)

Key:   suggestions:python
Value: ["python tutorial", "python download", "python 3.12", ...]
TTL:   3600 seconds

// Popular queries cached longer
Key:   suggestions:google
TTL:   86400 seconds (24 hours)
</code></pre>

    <h3>6. Suggestions Database</h3>
    <div class="tech-stack">
        <span class="tech-badge">PostgreSQL</span>
        <span class="tech-badge">Elasticsearch</span>
    </div>

    <h4>Schema</h4>
    <pre><code>CREATE TABLE suggestions (
    id BIGSERIAL PRIMARY KEY,
    query TEXT NOT NULL,
    frequency BIGINT DEFAULT 0,
    category VARCHAR(50),
    language VARCHAR(10) DEFAULT 'en',
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_query_prefix (query text_pattern_ops),
    INDEX idx_frequency (frequency DESC),
    INDEX idx_category (category)
);

-- Example data
| id  | query              | frequency | category    |
|-----|--------------------|-----------|-------------|
| 1   | iphone 15          | 5000000   | electronics |
| 2   | iphone 15 pro      | 3500000   | electronics |
| 3   | python tutorial    | 2000000   | programming |
| 4   | weather tomorrow   | 10000000  | general     |
</code></pre>

    <h3>7. Query Aggregator (Offline Processing)</h3>
    <div class="tech-stack">
        <span class="tech-badge">Apache Spark</span>
        <span class="tech-badge">Hadoop</span>
        <span class="tech-badge">AWS EMR</span>
    </div>

    <h4>Batch Processing Pipeline</h4>
    <pre><code>// Daily/hourly batch job
1. Read search logs from Kafka/S3
2. Aggregate query frequencies
3. Filter low-frequency queries (< 10 occurrences)
4. Calculate relevance scores
5. Update suggestions database
6. Rebuild Trie data structure
7. Push updated Trie to service nodes
</code></pre>

    <ul>
        <li><strong>Frequency:</strong> Run hourly for trending queries</li>
        <li><strong>Full Rebuild:</strong> Daily for complete update</li>
        <li><strong>Incremental Updates:</strong> Real-time for very popular queries</li>
    </ul>

    <h2>üîÑ Data Flow</h2>

    <h3>Read Path (User Query)</h3>
    <table>
        <tr>
            <th>Step</th>
            <th>Component</th>
            <th>Action</th>
            <th>Latency</th>
        </tr>
        <tr>
            <td>1</td>
            <td>Client</td>
            <td>User types "ipho" ‚Üí Debounce 300ms</td>
            <td>300ms</td>
        </tr>
        <tr>
            <td>2</td>
            <td>Client</td>
            <td>Send GET /api/suggestions?q=ipho</td>
            <td>-</td>
        </tr>
        <tr>
            <td>3</td>
            <td>Load Balancer</td>
            <td>Route to service</td>
            <td>< 1ms</td>
        </tr>
        <tr>
            <td>4</td>
            <td>Typeahead Service</td>
            <td>Check Redis cache</td>
            <td>1ms</td>
        </tr>
        <tr>
            <td>5a</td>
            <td>Cache Hit (95%)</td>
            <td>Return cached suggestions</td>
            <td>< 5ms total</td>
        </tr>
        <tr>
            <td>5b</td>
            <td>Cache Miss (5%)</td>
            <td>Query Trie in memory</td>
            <td>< 10ms total</td>
        </tr>
        <tr>
            <td>6</td>
            <td>Client</td>
            <td>Display suggestions dropdown</td>
            <td>-</td>
        </tr>
    </table>

    <h3>Write Path (Update Suggestions)</h3>
    <table>
        <tr>
            <th>Step</th>
            <th>Component</th>
            <th>Action</th>
            <th>Frequency</th>
        </tr>
        <tr>
            <td>1</td>
            <td>Search Events</td>
            <td>User searches logged to Kafka</td>
            <td>Real-time</td>
        </tr>
        <tr>
            <td>2</td>
            <td>Query Aggregator</td>
            <td>Process logs in batches (Spark)</td>
            <td>Hourly</td>
        </tr>
        <tr>
            <td>3</td>
            <td>Suggestions DB</td>
            <td>Update query frequencies</td>
            <td>Hourly</td>
        </tr>
        <tr>
            <td>4</td>
            <td>Trie Builder</td>
            <td>Rebuild Trie from updated data</td>
            <td>Hourly</td>
        </tr>
        <tr>
            <td>5</td>
            <td>Typeahead Service</td>
            <td>Hot-reload new Trie (zero downtime)</td>
            <td>Hourly</td>
        </tr>
        <tr>
            <td>6</td>
            <td>Redis Cache</td>
            <td>Auto-expires old entries (1hr TTL)</td>
            <td>Automatic</td>
        </tr>
    </table>

    <h2>üöÄ Scalability Features</h2>

    <h3>Horizontal Scaling</h3>
    <ul>
        <li><strong>Stateless Services:</strong> Each service node has full copy of Trie in memory</li>
        <li><strong>Load Balancer:</strong> Distributes traffic across 10-100 service nodes</li>
        <li><strong>Redis Cluster:</strong> Sharded cache for high throughput</li>
        <li><strong>Read Replicas:</strong> Database read replicas for query logs</li>
    </ul>

    <h3>Geographic Distribution</h3>
    <pre><code>US Region:
  - Typeahead Service (20 nodes)
  - Redis Cache (local)
  - Trie loaded in memory

EU Region:
  - Typeahead Service (10 nodes)
  - Redis Cache (local)
  - Same Trie (replicated)

Asia Region:
  - Typeahead Service (15 nodes)
  - Redis Cache (local)
  - Localized Trie (Chinese, Japanese queries)
</code></pre>

    <h3>Trie Memory Optimization</h3>
    <div class="comparison">
        <div class="comparison-box selected">
            <h4>‚úÖ Optimized Approach</h4>
            <ul>
                <li>Store only top 10M queries</li>
                <li>Filter queries with frequency < 100</li>
                <li>Compress common prefixes</li>
                <li>Use memory-efficient data structures</li>
                <li><strong>Memory: ~10GB per node</strong></li>
            </ul>
        </div>
        <div class="comparison-box">
            <h4>‚ùå Naive Approach</h4>
            <ul>
                <li>Store all 1B queries</li>
                <li>Include rare queries</li>
                <li>No compression</li>
                <li>Simple string storage</li>
                <li><strong>Memory: ~500GB per node</strong></li>
            </ul>
        </div>
    </div>

    <h2>üõ°Ô∏è Performance Optimizations</h2>

    <table>
        <tr>
            <th>Optimization</th>
            <th>Technique</th>
            <th>Impact</th>
        </tr>
        <tr>
            <td>Client Debouncing</td>
            <td>Wait 300ms after typing stops</td>
            <td>80% reduction in API calls</td>
        </tr>
        <tr>
            <td>Redis Caching</td>
            <td>Cache popular queries (1hr TTL)</td>
            <td>95% cache hit ratio, < 5ms response</td>
        </tr>
        <tr>
            <td>In-Memory Trie</td>
            <td>Full Trie loaded in RAM</td>
            <td>< 1ms lookup time</td>
        </tr>
        <tr>
            <td>Pre-computed Suggestions</td>
            <td>Store top 10 at each Trie node</td>
            <td>No runtime sorting needed</td>
        </tr>
        <tr>
            <td>CDN for Static Assets</td>
            <td>CloudFront for JS/CSS</td>
            <td>Reduced origin load</td>
        </tr>
        <tr>
            <td>Request Cancellation</td>
            <td>Abort previous requests</td>
            <td>Reduced server load</td>
        </tr>
    </table>

    <h2>üìà Monitoring & Observability</h2>

    <h3>Key Metrics</h3>
    <ul>
        <li><strong>Latency:</strong> p50, p95, p99 response times (target: p95 < 100ms)</li>
        <li><strong>Throughput:</strong> Requests per second per node</li>
        <li><strong>Cache Hit Ratio:</strong> Redis hits vs misses (target: > 90%)</li>
        <li><strong>Memory Usage:</strong> Trie size in RAM per node</li>
        <li><strong>Error Rate:</strong> 4xx, 5xx errors</li>
        <li><strong>Popular Queries:</strong> Most searched terms</li>
    </ul>

    <h3>Alerting</h3>
    <table>
        <tr>
            <th>Metric</th>
            <th>Warning</th>
            <th>Critical</th>
        </tr>
        <tr>
            <td>Latency (p95)</td>
            <td>> 50ms</td>
            <td>> 100ms</td>
        </tr>
        <tr>
            <td>Cache Hit Ratio</td>
            <td>< 85%</td>
            <td>< 80%</td>
        </tr>
        <tr>
            <td>Memory Usage</td>
            <td>> 80%</td>
            <td>> 90%</td>
        </tr>
        <tr>
            <td>Error Rate</td>
            <td>> 0.5%</td>
            <td>> 1%</td>
        </tr>
    </table>

    <div class="note">
        <strong>Tech Stack Summary:</strong>
        <br>‚Ä¢ Frontend: React/Vue.js with debouncing
        <br>‚Ä¢ Backend: Go/Node.js for Typeahead Service
        <br>‚Ä¢ Data Structure: Trie (in-memory) for fast lookups
        <br>‚Ä¢ Cache: Redis Cluster (95% hit ratio)
        <br>‚Ä¢ Database: PostgreSQL / Elasticsearch for suggestions storage
        <br>‚Ä¢ Processing: Apache Spark for log aggregation
        <br>‚Ä¢ Streaming: Kafka for real-time search logs
        <br>‚Ä¢ Monitoring: Prometheus, Grafana, or DataDog
    </div>

    <div class="warning">
        <strong>Key Design Decisions:</strong>
        <br>‚Ä¢ Use Trie (not database queries) for low latency
        <br>‚Ä¢ Load full Trie in memory on each service node
        <br>‚Ä¢ Client-side debouncing reduces API calls by 80%
        <br>‚Ä¢ Pre-compute top suggestions at each Trie node
        <br>‚Ä¢ Update Trie hourly (not real-time) for simplicity
        <br>‚Ä¢ Redis caching for popular queries (95% hit rate)
    </div>

</body>
</html>
